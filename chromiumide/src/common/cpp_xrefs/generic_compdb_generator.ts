// Copyright 2024 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import * as fs from 'fs';
import {TextDocument, CancellationToken} from 'vscode';
import * as vscode from 'vscode';
import {assertNever} from '../../../shared/app/common/typecheck';
import {CompdbGenerator, ErrorDetails, ShouldGenerateResult} from './types';

enum GenerationState {
  Generating,
  Generated,
  Failed,
}

/**
 * A compdb generator implementation that keeps track of the results of past compdb generation
 * attempts and don't run needless computations after success or failure.
 */
export class GenericCompdbGenerator implements CompdbGenerator {
  constructor(private readonly core: CompdbGeneratorCore) {}

  readonly name = this.core.name;

  // Packages for which compdb has been or being generated in this session.
  // Keyed by compdb path.
  private readonly generationStates = new Map<string, GenerationState>();

  async shouldGenerate(document: TextDocument): Promise<ShouldGenerateResult> {
    const scope = await this.core.generationScope(document);
    switch (scope) {
      case GenerationScope.Unsupported:
        return ShouldGenerateResult.NoUnsupported;
      case GenerationScope.Always:
        return ShouldGenerateResult.Yes;
      case GenerationScope.InitOnly:
        break;
      default:
        assertNever(scope);
    }

    const compdbPath = await this.core.compdbPath(document);
    const state = this.generationStates.get(compdbPath);
    switch (state) {
      case undefined:
        return ShouldGenerateResult.Yes;
      case GenerationState.Generated: {
        if (!fs.existsSync(compdbPath)) {
          // Corner case: compdb was generated but then manually removed. In
          // this case we can safely rerun the same command and regenerate it.
          return ShouldGenerateResult.Yes;
        }
        return ShouldGenerateResult.NoNeedNoChange;
      }
      case GenerationState.Generating:
        return ShouldGenerateResult.NoGenerating;
      case GenerationState.Failed:
        // We don't retry the generation if it fails. Instead we instruct the
        // user to manually fix the problem and then reload the IDE through the
        // error message.
        return ShouldGenerateResult.NoHasFailed;
      default:
        assertNever(state);
    }
  }

  async generate(
    document: TextDocument,
    token: CancellationToken
  ): Promise<void> {
    const compdbPath = await this.core.compdbPath(document);

    const previousState = this.generationStates.get(compdbPath);
    this.generationStates.set(compdbPath, GenerationState.Generating);

    const result = await this.core.generate(document, token);

    if (result instanceof Error) {
      if (token.isCancellationRequested) {
        if (!previousState) {
          this.generationStates.delete(compdbPath);
        } else {
          this.generationStates.set(compdbPath, previousState);
        }
        return;
      }
      this.generationStates.set(compdbPath, GenerationState.Failed);
      throw result;
    }

    this.generationStates.set(compdbPath, GenerationState.Generated);
  }
}

export enum GenerationScope {
  /** The class does not support compdb generation for the given document. */
  Unsupported,
  /** The class should always generate compdb when the given document is touched. */
  Always,
  /** The class should generate compdb only if no generation has been attempted in this session. */
  InitOnly,
}

export interface CompdbGeneratorCore {
  readonly name: string;

  /**
   * Returns whether compdb should be generated for the document.
   */
  generationScope(document: TextDocument): Promise<GenerationScope>;

  /**
   * The filepath of the compdb that would be generated by calling `generate` with the document.
   * This function is only called if `generationScope(document)` returns `Always` or `InitOnly`.
   */
  compdbPath(document: TextDocument): Promise<string>;

  /**
   * Generates a compilation database for the given document.
   */
  generate(
    document: TextDocument,
    token: CancellationToken
  ): Promise<undefined | ErrorDetails | vscode.CancellationError>;
}
